curr_info_criterion, criterion, "\n")
cat("\tBest model", "(Rate Cat", current_rate_category-1, "):",
best_info_criterion, criterion, "\n",
"\tCurrent model", "(Rate Cat", current_rate_category, "):",
curr_info_criterion, criterion, "\n")
corhmm_fit_l1
corhmm_fit_l1[[2]]
corhmm_fit_l1[[5]]
corhmm_fit_l1[[4]]
corhmm_fit_l1[[3]]
curr_fit <- corhmm_fit_l1[[4]]
curr_fit
current_rate_category
paste0("R", current_rate_category)
grep(paste0("R", current_rate_category), colnames(curr_fit$solution))
row_index <- grep(paste0("R", current_rate_category),
rownames(curr_fit$solution))
row_index
curr_fit$solution[,col_index]
col_index <- grep(paste0("R", current_rate_category),
colnames(curr_fit$solution))
row_index <- grep(paste0("R", current_rate_category),
rownames(curr_fit$solution))
curr_fit$solution[,col_index]
is.na(curr_fit$solution[,col_index])
all(is.na(curr_fit$solution[,col_index]))
row_na_test <- all(is.na(curr_fit$solution[row_index,]))
row_na_test
current_rate_category
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
dat <- primates[[2]]
# Main execution
#
#
#
# results_1 <- corHMM:::kFoldCrossValidation(corhmm_fit_l1, 5)
# results_1$averageScore
corhmm_fit <- corHMM(phy = phy,
data = dat,
rate.cat = 1,
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE)
corhmm_fit_l0 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 1,
merge.params = FALSE,
drop.par = FALSE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE,
lambda = 0,
p = corHMM:::MatrixToPars(corhmm_fit),
rate.cat = 1)
corhmm_fit_l0
corhmm_fit
corhmm_fit_l1 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 2,
merge.params = TRUE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = TRUE,
collapse = FALSE,
lambda = 1)
corhmm_fit_l1
debug(corHMM:::corHMMDredge)
corhmm_fit_l1 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 2,
merge.params = TRUE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = TRUE,
collapse = FALSE,
lambda = 1)
curr_fit
fit_set
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
dat <- primates[[2]]
phy$edge.length <- phy$edge.length + 1e-6
# Main execution
#
#
#
# results_1 <- corHMM:::kFoldCrossValidation(corhmm_fit_l1, 5)
# results_1$averageScore
corhmm_fit <- corHMM(phy = phy,
data = dat,
rate.cat = 1,
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE)
corhmm_fit_l0 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 1,
merge.params = FALSE,
drop.par = FALSE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE,
lambda = 0,
p = corHMM:::MatrixToPars(corhmm_fit),
rate.cat = 1)
corhmm_fit_l1 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 2,
merge.params = TRUE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = TRUE,
collapse = FALSE,
lambda = 1)
diff(-Inf, 10)
diff(c(-Inf, 10))
diff(c(10, -Inf))
diff(c(Inf, 10))
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
dat <- primates[[2]]
phy$edge.length <- phy$edge.length + 1e-6
# Main execution
#
#
#
# results_1 <- corHMM:::kFoldCrossValidation(corhmm_fit_l1, 5)
# results_1$averageScore
corhmm_fit <- corHMM(phy = phy,
data = dat,
rate.cat = 1,
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE)
corhmm_fit_l0 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 1,
merge.params = FALSE,
drop.par = FALSE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE,
lambda = 0,
p = corHMM:::MatrixToPars(corhmm_fit),
rate.cat = 1)
corhmm_fit_l1 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 2,
merge.params = TRUE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = TRUE,
collapse = FALSE,
lambda = 1)
corhmm_fit_l1
best_merge_criterion[[3]]
corhmm_fit_l1[[3]]
corhmm_fit_l1[[3]]$index.mat
corhmm_fit_2 <- corHMM(phy = phy,
data = dat,
rate.cat = 1,
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE,
rate.mat = corhmm_fit_l1[[3]]$index.mat)
corhmm_fit_2
corhmm_fit
par(mfrow=c(1,2), mar=c(.1,.1,.1,.1))
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = corhmm_fit$data.legend[,2])
nodelabels(pie = corhmm_fit$states, piecol = c("black", "red", "green", "blue"))
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = corhmm_fit_2$data.legend[,2])
nodelabels(pie = corhmm_fit_2$states, piecol = c("black", "red", "green", "blue"))
corhmm_fit_l1
corhmm_fit_l1
par(mfrow=c(1,2), mar=c(.1,.1,.1,.1))
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = corhmm_fit$data.legend[,2])
nodelabels(pie = corhmm_fit$states, piecol = c("black", "red", "green", "blue"))
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = corhmm_fit_l1[[3]]$data.legend[,2])
nodelabels(pie = corhmm_fit_l1[[3]]$states, piecol = c("black", "red", "green", "blue"))
results <- corHMM:::kFoldCrossValidation(corhmm_fit_l1, 5, c(0,.25,.5,.75,1))
par(mfrow=c(1,2), mar=c(.1,.1,.1,.1))
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = corhmm_fit_2$data.legend[,2])
nodelabels(pie = corhmm_fit_2$states, piecol = c("black", "red", "green", "blue"))
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = corhmm_fit_l1[[3]]$data.legend[,2])
nodelabels(pie = corhmm_fit_l1[[3]]$states, piecol = c("black", "red", "green", "blue"))
results <- corHMM:::kFoldCrossValidation(corhmm_fit_l1, 5, c(0,.25,.5,.75,1))
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
dat <- primates[[2]]
phy$edge.length <- phy$edge.length + 1e-6
# Main execution
#
#
#
# results_1 <- corHMM:::kFoldCrossValidation(corhmm_fit_l1, 5)
# results_1$averageScore
corhmm_fit <- corHMM(phy = phy,
data = dat,
rate.cat = 1,
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE)
corhmm_fit_l0 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 1,
merge.params = FALSE,
drop.par = FALSE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = FALSE,
collapse = FALSE,
lambda = 0,
p = corHMM:::MatrixToPars(corhmm_fit),
rate.cat = 1)
corhmm_fit_l1 <- corHMM:::corHMMDredge(phy = phy,
data = dat,
max.rate.cat = 2,
merge.params = TRUE,
drop.par = TRUE,
pen.type = "l1",
root.p="maddfitz",
get.tip.states = TRUE,
collapse = FALSE,
lambda = 1)
corhmm_fit_l1
corhmm_fit_l1
results <- corHMM:::kFoldCrossValidation(corhmm_fit_l1[[3]], 5, c(0,.25,.5,.75,1))
results
corhmm_fit_l1[[3]]
debug(corHMM:::kFoldCrossValidation)
results <- corHMM:::kFoldCrossValidation(corhmm_fit_l1[[3]], 5, c(0,.25,.5,.75,1))
folds
ip
fold_data
corhmm_obj
simulateData <- function(ntaxa){
meets_criteria_phy_index <- integer(0)
while(length(meets_criteria_phy_index) == 0){
phy <- sim.bdtree(b= 1, d = 0.5, "taxa", ntaxa, extinct = FALSE)
phy <- drop.extinct(phy)
phy <- ladderize(phy)
subphy <- subtrees(phy)
meets_criteria_phy_index <- which((unlist(lapply(subphy, function(x) length(x$tip.label))) > (ntaxa * .4)) & (unlist(lapply(subphy, function(x) length(x$tip.label))) < (ntaxa * .6)))
}
# unrepliclated bursts
# generate character X
meets_criteria_phy_index <- meets_criteria_phy_index[1]
dat <- data.frame(sp = phy$tip.label, X = 0, Y = 0)
dat[dat$sp %in% subphy[[meets_criteria_phy_index]]$tip.label, 2] <- 1
# generate character Y
sim_dat <- sim.char(phy, matrix(c(-100,100,100,-100), 2, 2), 1, "discrete")
dat[dat$sp %in% subphy[[meets_criteria_phy_index]]$tip.label, 3] <- sim_dat[rownames(sim_dat) %in% subphy[[meets_criteria_phy_index]]$tip.label] - 1
burst_dat <- dat
# darwins scenario
# generate character X
# generate character Y
dat <- data.frame(sp = phy$tip.label, X = 0, Y = 0)
dat[dat$sp %in% subphy[[meets_criteria_phy_index]]$tip.label, c(2,3)] <- 1
darwins_dat_both <- darwins_dat_outside <- darwins_dat_inside <- darwins_dat <- dat
# set up the modified scenarios
# outside focal clade
tips.to.switch.00 <- sample(which(paste0(darwins_dat$X, darwins_dat$Y) == "00"), 2)
darwins_dat_outside[tips.to.switch.00[1], 2:3] <- c(1,0)
darwins_dat_outside[tips.to.switch.00[2], 2:3] <- c(0,1)
# inside focal clade
tips.to.switch.11 <- sample(which(paste0(burst_dat$X, burst_dat$Y) == "11"), 2)
darwins_dat_inside[tips.to.switch.11[1], 2:3] <- c(1,0)
darwins_dat_inside[tips.to.switch.11[2], 2:3] <- c(0,1)
# both
darwins_dat_both[tips.to.switch.00[1], 2:3] <- c(1,0)
darwins_dat_both[tips.to.switch.00[2], 2:3] <- c(0,1)
darwins_dat_both[tips.to.switch.11[1], 2:3] <- c(1,0)
darwins_dat_both[tips.to.switch.11[2], 2:3] <- c(0,1)
return(list(phy=phy, darwin_dat=darwins_dat, burst_dat=burst_dat, darwins_dat_outside=darwins_dat_outside, darwins_dat_inside=darwins_dat_inside, darwins_dat_both=darwins_dat_both))
}
madd_data <- simulateData(500)
require(corHMM)
require(geiger)
require(parallel)
madd_data <- simulateData(500)
madd_data
rate.mat <- getFullMat(list(getRateCatMat(2),getRateCatMat(2)), getRateCatMat(2))
colnames(rate.mat) <- rownames(rate.mat) <- c("0,0", "0,1", "1,0", "1,1")
rate.mat[rate.mat != 0] <- 1:8
rate.mat
# independent models
rate_mat_ind <- equateStateMatPars(rate.mat, list(c(3,8), c(5,7), c(1,6), c(2,4)))
rate_mat_ind
rate_mat_ind_2 <- getFullMat(list(rate_mat_ind, rate_mat_ind), equateStateMatPars(getRateCatMat(2), 1:2))
rate_mat_ind_2
cor_test <- fitCorrelationTest(madd_data$phy, madd_data$darwin_dat)
madd_data <- simulateData(500)
cor_test <- fitCorrelationTest(madd_data$phy, madd_data$darwin_dat)
fitCorrelationTest
debug()
debug(fitCorrelationTest)
cor_test <- fitCorrelationTest(madd_data$phy, madd_data$darwin_dat)
cor_test <- fitCorrelationTest(madd_data$phy, madd_data$darwin_dat)
data
corHMM(phy = phy, data = data,
rate.cat = 1, rate.mat = indep_model_1)
indep_model_1
cor_dat <- madd_data
cor_dat <- madd_data$darwin_dat
cor_dat$X
as.factor(cor_dat$X)
cor_dat$Y <- as.factor(cor_dat$Y)
cor_dat
cor_dat$Y
cor_dat$X
cor_test <- fitCorrelationTest(madd_data$phy, madd_data$darwin_dat)
corHMM(phy = phy, data = data,
rate.cat = 1, rate.mat = indep_model_1)
indep_model_1
corHMM(phy = phy, data = data,
rate.cat = 1, rate.mat = indep_model_1, collapse = FALSE)
# simple binary simulation
setwd("~/corhmm-dredge/")
library(corHMM)
source("code/utils.R")
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=1)
index_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=1)
index_mat$full_rate_mat
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=2, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=2, nStates=2, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=2, nRateClass=1)
index_mat$full_rate_mat
cm * (cm-1)
# 2 binary
# C1=2, C2=2, C3=2, C=3
cm <- c(2,2,2)
C <- 3
cm * (cm-1)
(cm * (cm-1)) * C
sum((cm * (cm-1)) * C)
index_mat$full_rate_mat
C
index_mat
index_mat$min_df
tmp <- index_mat$min_df
tmp[,3]
tmp[1,4] <- 3
getStateMat4Dat(tmp)
index_mat$full_rate_mat
getStateMat4Dat(tmp, collapse = FALSE)
tmp[1,3] <- 3
getStateMat4Dat(tmp, collapse = FALSE)
test$
test <- getStateMat4Dat(tmp, collapse = FALSE)
test$rate.mat
sum(test$rate.mat[1,] != 0)
sum(test$rate.mat[2,] != 0)
apply(test$rate.mat, 1, function(x) sum(x!=0))
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=2, nStates=2, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=2, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=2, nStates=3, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=3, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=4, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=2, nStates=2, nRateClass=1)
index_mat$full_rate_mat
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=2, nStates=3, nRateClass=1)
index_mat$full_rate_mat
sum(cm-1)
sum(cm-1)*sum(cm)
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=2, nRateClass=1)
index_mat$full_rate_mat
tmp <- index_mat$min_df
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(2,2,2)
C <- 3
sum(cm-1)*sum(cm)
sum(cm-1)
sum(cm)
getStateMat4Dat
corProcessData
corHMM:::corProcessData
?expand.grid
prod(cm)
sum(cm-1)*prod(cm)
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=3, nRateClass=1)
index_mat$full_rate_mat
tmp <- index_mat$min_df
tmp
index_mat$full_rate_mat
max(index_mat$full_rate_mat)
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,3,3)
C <- 3
max(index_mat$full_rate_mat)
sum(cm-1)*prod(cm)
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=4, nRateClass=1)
index_mat$full_rate_mat
tmp <- index_mat$min_df
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,3,3)
C <- 3
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(4,4,4)
C <- 3
max(index_mat$full_rate_mat)
sum(cm-1)*prod(cm)
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=3, nRateClass=1)
index_mat$full_rate_mat
tmp <- index_mat$min_df
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(4,4,4)
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,3,3)
C <- 3
max(index_mat$full_rate_mat)
sum(cm-1)*prod(cm)
tmp
tmp[1,3] <- 4
tmp[1,3] <- 4
test <- getStateMat4Dat(tmp, collapse = FALSE)
apply(test$rate.mat, 1, function(x) sum(x!=0))
max(test$rate.mat)
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,3,4)
C <- 3
max(index_mat$full_rate_mat)
sum(cm-1)*prod(cm)
tmp[1,5] <- 5
test <- getStateMat4Dat(tmp, collapse = FALSE)
max(test$rate.mat)
tmp
tmp[1,3] <- 4
tmp[1,5] <- 5
tmp
tmp <- index_mat$min_df
tmp[1,3] <- 4
tmp[1,5] <- 5
tmp
tmp <- index_mat$min_df
tmp[1,3] <- 4
tmp[2,5] <- 4
test <- getStateMat4Dat(tmp, collapse = FALSE)
max(test$rate.mat)
tmp
tmp <- index_mat$min_df
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,3,4)
C <- 3
max(index_mat$full_rate_mat)
sum(cm-1)*prod(cm)
tmp[1,3] <- 4
tmp[2,3] <- 5
test <- getStateMat4Dat(tmp, collapse = FALSE)
max(test$rate.mat)
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,3,5)
C <- 3
max(index_mat$full_rate_mat)
sum(cm-1)*prod(cm)
# C1=2, C2=2, C3=2, C=3
# (summ cm-1) * S
cm <- c(3,4,5)
C <- 3
sum(cm-1)*prod(cm)
tmp[1,2] <- 4
tmp[1,3] <- 4
tmp[2,3] <- 5
test <- getStateMat4Dat(tmp, collapse = FALSE)
max(test$rate.mat)
