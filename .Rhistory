c(y_min, profile_data$lnLik, y_min), col = "lightgrey", border = NA)
# Mark the MLE with a point and label
points(mle_pars[i], loglik, pch = 19, col = "blue")
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = 0.7)
# Draw a dashed horizontal line for the 95% confidence interval
abline(h = ci_limit, col = "black", lty = 2)
# Manually add rotated x-axis labels for log scale within plot range and more granularity
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = -0.2) # Ticks point inwards
labels = sapply(log_ticks, function(x) sprintf("%.1e", x)) # Format with scientific notation
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = 0.7)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
plot_batch_profile_lik(corhmm_profile)
plot_batch_profile_lik <- function(corhmm_profile) {
n_params <- length(corhmm_profile) - 1
n_cols <- ceiling(sqrt(n_params))
n_rows <- ceiling(n_params / n_cols)
layout(matrix(1:(n_rows*n_cols), nrow = n_rows, byrow = TRUE))
par(mar = c(5, 4, 4, 1) + 0.1) # Adjust bottom margin to accommodate rotated labels
# Extract global min and max log-likelihood values
all_lliks <- unlist(lapply(corhmm_profile[1:n_params], function(x) x$profile_table$lnLik))
y_min <- min(all_lliks)
y_max <- max(all_lliks)
mle_pars <- corHMM:::MatrixToPars(corhmm_profile$corhmm_obj)
loglik <- corhmm_profile$corhmm_obj$loglik
ci_limit = loglik - 1.96 # Define the CI limit for log-likelihood values
param_names = names(mle_pars)
for (i in 1:n_params) {
plot(corhmm_profile[[i]]$profile_table, type = "n", log = "x", bty = "n", axes = FALSE,
main = param_names[i], xlab = "", ylab = "", ylim = c(y_min, y_max), xaxt="n")
box()
axis(side = 2, las = 1, tcl = -0.2) # Ticks point inwards
title(xlab = "Parameter Value", ylab = "Log-Likelihood", line = 2.5)
profile_data = corhmm_profile[[i]]$profile_table
# Draw the main curve
lines(profile_data$par_value, profile_data$lnLik, type = "l")
# Fill the entire area under the curve with light grey
polygon(c(min(profile_data$par_value), profile_data$par_value, max(profile_data$par_value)),
c(y_min, profile_data$lnLik, y_min), col = "lightgrey", border = NA)
# Mark the MLE with a point and label
points(mle_pars[i], loglik, pch = 19, col = "blue")
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = 0.7)
# Draw a dashed horizontal line for the 95% confidence interval
abline(h = ci_limit, col = "black", lty = 2)
# Manually add rotated x-axis labels for log scale within plot range and more granularity
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = -0.2) # Ticks point inwards
labels = sapply(log_ticks, function(x) sprintf("%.1e", x)) # Format with scientific notation
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = 0.7)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
plot_batch_profile_lik(corhmm_profile)
plot_batch_profile_lik <- function(corhmm_profile) {
n_params <- length(corhmm_profile) - 1
n_cols <- ceiling(sqrt(n_params))
n_rows <- ceiling(n_params / n_cols)
layout(matrix(1:(n_rows*n_cols), nrow = n_rows, byrow = TRUE))
par(mar = c(5, 4, 4, 1) + 0.1) # Adjust bottom margin to accommodate rotated labels
# Extract global min and max log-likelihood values
all_lliks <- unlist(lapply(corhmm_profile[1:n_params], function(x) x$profile_table$lnLik))
y_min <- min(all_lliks)
y_max <- max(all_lliks)
mle_pars <- corHMM:::MatrixToPars(corhmm_profile$corhmm_obj)
loglik <- corhmm_profile$corhmm_obj$loglik
ci_limit = loglik - 1.96 # Define the CI limit for log-likelihood values
param_names = names(mle_pars)
for (i in 1:n_params) {
plot(corhmm_profile[[i]]$profile_table, type = "n", log = "x", bty = "n", axes = FALSE,
main = param_names[i], xlab = "", ylab = "", ylim = c(y_min, y_max), xaxt="n")
box()
axis(side = 2, las = 1, tcl = -0.2) # Ticks point inwards
title(xlab = "Parameter Value", ylab = "Log-Likelihood", line = 2.5)
profile_data = corhmm_profile[[i]]$profile_table
# Fill the entire area under the curve with light grey
polygon(c(min(profile_data$par_value), profile_data$par_value, max(profile_data$par_value)),
c(y_min, profile_data$lnLik, y_min), col = "lightgrey", border = NA)
# Draw the main curve
lines(profile_data$par_value, profile_data$lnLik, type = "l")
# Mark the MLE with a point and label
points(mle_pars[i], loglik, pch = 19, col = "blue")
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = 0.7)
# Draw a dashed horizontal line for the 95% confidence interval
abline(h = ci_limit, col = "black", lty = 2)
# Manually add rotated x-axis labels for log scale within plot range and more granularity
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = -0.2) # Ticks point inwards
labels = sapply(log_ticks, function(x) sprintf("%.1e", x)) # Format with scientific notation
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = 0.7)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
plot_batch_profile_lik(corhmm_profile)
plot_batch_profile_lik <- function(corhmm_profile, n_cols = NULL, n_rows = NULL,
mar = c(5, 4, 4, 1) + 0.1, ci_level = 1.96,
polygon_col = "lightgrey", line_col = "black", line_type = "l",
mle_col = "blue", ci_line_col = "black", ci_line_type = "dashed",
axis_tick_length = -0.2, label_cex = 0.7){
# Calculate the number of parameters and adjust layout if not manually specified
n_params <- length(corhmm_profile) - 1
if(is.null(n_cols) || is.null(n_rows)) {
n_cols <- ceiling(sqrt(n_params))
n_rows <- ceiling(n_params / n_cols)
}
layout(matrix(1:(n_rows*n_cols), nrow = n_rows, byrow = TRUE))
par(mar = mar) # Use the user-defined margins
all_lliks <- unlist(lapply(corhmm_profile[1:n_params], function(x) x$profile_table$lnLik))
y_min <- min(all_lliks)
y_max <- max(all_lliks)
mle_pars <- corHMM:::MatrixToPars(corhmm_profile$corhmm_obj)
loglik <- corhmm_profile$corhmm_obj$loglik
ci_limit = loglik - ci_level # Adjusted for user-defined CI level
param_names = names(mle_pars)
for (i in 1:n_params) {
plot(corhmm_profile[[i]]$profile_table, type = "n", log = "x", bty = "n", axes = FALSE,
main = param_names[i], xlab = "", ylab = "", ylim = c(y_min, y_max), xaxt="n")
box()
axis(side = 2, las = 1, tcl = axis_tick_length) # User-defined tick length
title(xlab = "Parameter Value", ylab = "Log-Likelihood", line = 2.5)
profile_data = corhmm_profile[[i]]$profile_table
polygon(c(min(profile_data$par_value), profile_data$par_value, max(profile_data$par_value)),
c(y_min, profile_data$lnLik, y_min), col = polygon_col, border = NA)
lines(profile_data$par_value, profile_data$lnLik, type = line_type, col = line_col)
points(mle_pars[i], loglik, pch = 19, col = mle_col)
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = label_cex, col = line_col)
abline(h = ci_limit, col = ci_line_col, lty = ci_line_type)
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = axis_tick_length)
labels = sapply(log_ticks, function(x) sprintf("%.1e", x))
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = label_cex)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
plot_batch_profile_lik(corhmm_profile)
corhmm_profile
corhmm_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit,
range_factor = 100,
n_points = 10,
ncores = 10,
dredge = FALSE)
plot_batch_profile_lik(corhmm_profile)
corhmm_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit,
range_factor = 1000,
n_points = 20,
ncores = 10,
dredge = FALSE)
plot_batch_profile_lik(corhmm_profile)
corhmm_fit_dredge <- corHMM:::corHMMDredge(phy = phy, data = data, 1, pen_type = "l1")
dredge_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit_dredge,
range_factor = 1000,
n_points = 20,
ncores = 10,
dredge = TRUE)
plot_batch_profile_lik(dredge_profile)
plot_batch_profile_lik <- function(corhmm_profile, n_cols = NULL, n_rows = NULL,
mar = c(5, 4, 4, 1) + 0.1, ci_level = 1.96,
polygon_col = "lightgrey", line_col = "black", line_type = "l",
mle_col = "blue", ci_line_col = "black", ci_line_type = "dashed",
axis_tick_length = -0.2, label_cex = 0.7, ylim=NULL){
# Calculate the number of parameters and adjust layout if not manually specified
n_params <- length(corhmm_profile) - 1
if(is.null(n_cols) || is.null(n_rows)) {
n_cols <- ceiling(sqrt(n_params))
n_rows <- ceiling(n_params / n_cols)
}
layout(matrix(1:(n_rows*n_cols), nrow = n_rows, byrow = TRUE))
par(mar = mar) # Use the user-defined margins
all_lliks <- unlist(lapply(corhmm_profile[1:n_params], function(x) x$profile_table$lnLik))
if(is.null(ylim)){
y_min <- min(all_lliks)
y_max <- max(all_lliks)
}else{
y_min <- ylim[1]
y_max <- ylim[2]
}
mle_pars <- corHMM:::MatrixToPars(corhmm_profile$corhmm_obj)
loglik <- corhmm_profile$corhmm_obj$loglik
ci_limit = loglik - ci_level # Adjusted for user-defined CI level
param_names = names(mle_pars)
for (i in 1:n_params) {
plot(corhmm_profile[[i]]$profile_table, type = "n", log = "x", bty = "n", axes = FALSE,
main = param_names[i], xlab = "", ylab = "", ylim = c(y_min, y_max), xaxt="n")
box()
axis(side = 2, las = 1, tcl = axis_tick_length) # User-defined tick length
title(xlab = "Parameter Value", ylab = "Log-Likelihood", line = 2.5)
profile_data = corhmm_profile[[i]]$profile_table
polygon(c(min(profile_data$par_value), profile_data$par_value, max(profile_data$par_value)),
c(y_min, profile_data$lnLik, y_min), col = polygon_col, border = NA)
lines(profile_data$par_value, profile_data$lnLik, type = line_type, col = line_col)
points(mle_pars[i], loglik, pch = 19, col = mle_col)
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = label_cex, col = line_col)
abline(h = ci_limit, col = ci_line_col, lty = ci_line_type)
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = axis_tick_length)
labels = sapply(log_ticks, function(x) sprintf("%.1e", x))
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = label_cex)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
plot_batch_profile_lik(dredge_profile, ylim = c(-50, -40))
plot_batch_profile_lik(corhmm_profile)
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
corhmm_fit <- corHMM(phy = phy, data = data, rate.cat = 1)
corhmm_fit_dredge <- corHMM:::corHMMDredge(phy = phy, data = data, 1, pen_type = "l1")
corhmm_fit_dredge
corhmm_fit_dredge
corhmm_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit,
range_factor = 10000,
n_points = 20,
ncores = 10,
dredge = FALSE)
# Function to generate logarithmically spaced points
generate_log_points <- function(mle, range_factor, n_points = 10){
# mle: Maximum Likelihood Estimate of the parameter
# range_factor: Multiplicative factor to define the range around the MLE
# n_points: Number of points to generate
min_val <- sapply(mle, function(x) x / range_factor)
max_val <- sapply(mle, function(x) x * range_factor)
log_space <- mapply(function(x,y)
exp(seq(log(x), log(y), length.out = n_points)), x = min_val, y = max_val)
return(log_space)
}
fixed_corhmm <- function(par_free_0, par_fixed, par_fixed_index, dredge){
pars <- rep(NA, length.out = length(c(par_free_0, par_fixed)))
pars[par_fixed_index] <- exp(par_fixed)
pars[-par_fixed_index] <- exp(par_free_0)
neglnLik <- corHMM:::compute_neglnlikelihood(pars,  corhmm_fit)
if(dredge){
neglnLik <- neglnLik + sum(pars)
}
return(neglnLik)
}
optimize_fixed_corhmm <- function(par_free_0, par_fixed, par_fixed_index, dredge){
optim_result <- optim(par = log(par_free_0),
fn = fixed_corhmm,
method = "Nelder-Mead",
par_fixed = log(par_fixed),
par_fixed_index=par_fixed_index,
dredge=dredge)
return(optim_result)
}
get_profile_lik <- function(par_free_0, par_fixed_values, par_fixed_index, ncores=NULL, dredge=FALSE){
if(is.null(ncores)){
optim_res_list <- lapply(par_fixed_values, function(x)
optimize_fixed_corhmm(par_free_0, x, par_fixed_index, dredge))
}else{
ncores = min(parallel::detectCores()-1, ncores)
optim_res_list <- parallel::mclapply(par_fixed_values, function(x)
optimize_fixed_corhmm(par_free_0, x, par_fixed_index, dredge), mc.cores = ncores)
}
profile_table <- data.frame(par_value = par_fixed_values,
lnLik = -unlist(lapply(optim_res_list, "[[", "value")))
return(list(profile_table=profile_table,
optim_res=optim_res_list))
}
# Assuming generate_log_points is defined elsewhere and works as intended
# Wrapper function to perform profile likelihood analysis for multiple parameters
get_batch_profile_lik <- function(corhmm_obj, range_factor, n_points, ncores=NULL, dredge=FALSE) {
# Generate logarithmically spaced points for all parameters
# mle_pars is expected to be a named list or vector of MLEs for each parameter
mle_pars <- corHMM:::MatrixToPars(corhmm_obj)
log_points_list <- generate_log_points(mle_pars, range_factor, n_points)
profile_lik_results <- list()
for(i in seq_along(mle_pars)){
param_name <- names(mle_pars)[i]
par_fixed_values <- log_points_list[, i]
result <- get_profile_lik(mle_pars[-i], par_fixed_values, i, ncores, dredge)
profile_lik_results[[param_name]] <- result
}
profile_lik_results$corhmm_obj = corhmm_obj
return(profile_lik_results)
}
plot_batch_profile_lik <- function(corhmm_profile, n_cols = NULL, n_rows = NULL,
mar = c(5, 4, 4, 1) + 0.1, ci_level = 1.96,
polygon_col = "lightgrey", line_col = "black", line_type = "l",
mle_col = "blue", ci_line_col = "black", ci_line_type = "dashed",
axis_tick_length = -0.2, label_cex = 0.7, ylim=NULL){
# Calculate the number of parameters and adjust layout if not manually specified
n_params <- length(corhmm_profile) - 1
if(is.null(n_cols) || is.null(n_rows)) {
n_cols <- ceiling(sqrt(n_params))
n_rows <- ceiling(n_params / n_cols)
}
layout(matrix(1:(n_rows*n_cols), nrow = n_rows, byrow = TRUE))
par(mar = mar) # Use the user-defined margins
all_lliks <- unlist(lapply(corhmm_profile[1:n_params], function(x) x$profile_table$lnLik))
if(is.null(ylim)){
y_min <- min(all_lliks)
y_max <- max(all_lliks)
}else{
y_min <- ylim[1]
y_max <- ylim[2]
}
mle_pars <- corHMM:::MatrixToPars(corhmm_profile$corhmm_obj)
loglik <- corhmm_profile$corhmm_obj$loglik
ci_limit = loglik - ci_level # Adjusted for user-defined CI level
param_names = names(mle_pars)
for (i in 1:n_params) {
plot(corhmm_profile[[i]]$profile_table, type = "n", log = "x", bty = "n", axes = FALSE,
main = param_names[i], xlab = "", ylab = "", ylim = c(y_min, y_max), xaxt="n")
box()
axis(side = 2, las = 1, tcl = axis_tick_length) # User-defined tick length
title(xlab = "Parameter Value", ylab = "Log-Likelihood", line = 2.5)
profile_data = corhmm_profile[[i]]$profile_table
polygon(c(min(profile_data$par_value), profile_data$par_value, max(profile_data$par_value)),
c(y_min, profile_data$lnLik, y_min), col = polygon_col, border = NA)
lines(profile_data$par_value, profile_data$lnLik, type = line_type, col = line_col)
points(mle_pars[i], loglik, pch = 19, col = mle_col)
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = label_cex, col = line_col)
abline(h = ci_limit, col = ci_line_col, lty = ci_line_type)
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = axis_tick_length)
labels = sapply(log_ticks, function(x) sprintf("%.1e", x))
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = label_cex)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
corhmm_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit,
range_factor = 10000,
n_points = 20,
ncores = 10,
dredge = FALSE)
plot_batch_profile_lik(corhmm_profile)
dredge_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit_dredge,
range_factor = 10000,
n_points = 20,
ncores = 10,
dredge = TRUE)
plot_batch_profile_lik <- function(corhmm_profile, n_cols = NULL, n_rows = NULL,
mar = c(5, 4, 4, 1) + 0.1, ci_level = 1.96,
polygon_col = "lightgrey", line_col = "black", line_type = "l",
mle_col = "blue", ci_line_col = "black", ci_line_type = "dashed",
axis_tick_length = -0.2, label_cex = 0.7, ylim=NULL){
# Calculate the number of parameters and adjust layout if not manually specified
n_params <- length(corhmm_profile) - 1
if(is.null(n_cols) || is.null(n_rows)) {
n_cols <- ceiling(sqrt(n_params))
n_rows <- ceiling(n_params / n_cols)
}
layout(matrix(1:(n_rows*n_cols), nrow = n_rows, byrow = TRUE))
par(mar = mar) # Use the user-defined margins
all_lliks <- unlist(lapply(corhmm_profile[1:n_params], function(x) x$profile_table$lnLik))
if(is.null(ylim)){
y_min <- min(all_lliks)
y_max <- max(all_lliks)
}else{
y_min <- ylim[1]
y_max <- ylim[2]
}
mle_pars <- corHMM:::MatrixToPars(corhmm_profile$corhmm_obj)
loglik <- corhmm_profile$corhmm_obj$loglik
ci_limit = loglik - ci_level # Adjusted for user-defined CI level
param_names = names(mle_pars)
for (i in 1:n_params) {
plot(corhmm_profile[[i]]$profile_table, type = "n", log = "x", bty = "n", axes = FALSE,
main = param_names[i], xlab = "", ylab = "", ylim = c(y_min, y_max), xaxt="n")
grid()
axis(side = 2, las = 1, tcl = axis_tick_length) # User-defined tick length
title(xlab = "Parameter Value", ylab = "Log-Likelihood", line = 2.5)
profile_data = corhmm_profile[[i]]$profile_table
polygon(c(min(profile_data$par_value), profile_data$par_value, max(profile_data$par_value)),
c(y_min, profile_data$lnLik, y_min), col = polygon_col, border = NA)
lines(profile_data$par_value, profile_data$lnLik, type = line_type, col = line_col)
points(mle_pars[i], loglik, pch = 19, col = mle_col)
text(x = mle_pars[i] * 1.1, y = loglik, labels = paste("MLE =", round(mle_pars[i], 3)), pos = 4, cex = label_cex, col = line_col)
abline(h = ci_limit, col = ci_line_col, lty = ci_line_type)
x_range = range(profile_data$par_value)
log_ticks = exp(seq(log(x_range[1]), log(x_range[2]), length.out = 5))
axis(side = 1, at = log_ticks, labels = FALSE, tcl = axis_tick_length)
labels = sapply(log_ticks, function(x) sprintf("%.1e", x))
text(x = log_ticks,
y = par("usr")[3] - (par("usr")[4]-par("usr")[3])*0.05,
labels = labels, srt = 45, adj = 1, xpd = TRUE, cex = label_cex)
}
par(mar = c(5, 4, 4, 2) + 0.1) # Reset default margins
}
plot_batch_profile_lik(dredge_profile, ylim = c(-55, -40))
plot_batch_profile_lik(corhmm_profile)
pars
dredge_profile
dredge_profile$`0|1 -> 0|0`
dredge_profile$`0|1 -> 0|0`$optim_res
dredge_profile$`0|1 -> 0|0`$optim_res[[20]]
dredge_profile$`0|1 -> 0|0`$optim_res[[20]]$convergence
dredge_profile$`0|1 -> 0|0`$optim_res[[1]]$convergence
dredge_profile$`0|1 -> 0|0`$optim_res[[20]]$par
exp(dredge_profile$`0|1 -> 0|0`$optim_res[[20]]$par)
fixed_pars <- exp(dredge_profile$`0|1 -> 0|0`$optim_res[[20]]$par)
fixed_pars
free_pars <- exp(dredge_profile$`0|1 -> 0|0`$optim_res[[20]]$value)
free_pars
exp(corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$par)
corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$value
corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$value
fixed_pars
exp(corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$par
)
corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$value
corhmm_profile$`0|1 -> 0|0`$profile_table
corhmm_profile$`0|1 -> 0|0`$profile_table[20,]
exp(corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$par)
pars_b <- exp(corhmm_profile$`0|1 -> 0|0`$optim_res[[20]]$par)
corhmm_profile$`0|1 -> 0|0`$profile_table[20,]
corhmm_profile$`0|1 -> 0|0`$profile_table[20,1]
pars_a <- corhmm_profile$`0|1 -> 0|0`$profile_table[20,1]
corHMM:::compute_neglnlikelihood(c(pars_a, pars_b), corhmm_fit)
corhmm_fit
plot_batch_profile_lik(dredge_profile, ylim = c(-55, -40))
plot_batch_profile_lik(corhmm_profile)
knitr::opts_chunk$set(echo = TRUE)
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
corhmm_fit <- corHMM(phy = phy, data = data, rate.cat = 1)
corhmm_fit_dredge <- corHMM:::corHMMDredge(phy = phy, data = data, 1, pen_type = "l1")
?corHMM
knitr::opts_chunk$set(echo = TRUE)
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
corhmm_fit <- corHMM(phy = phy, data = data, rate.cat = 1)
corhmm_fit_dredge <- corHMM:::corHMMDredge(phy = phy, data = data, 1, pen_type = "l1")
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
corhmm_fit <- corHMM(phy = phy, data = data, rate.cat = 1)
corhmm_fit_dredge <- corHMM:::corHMMDredge(phy = phy, data = data, 1, pen_type = "l1")
corhmm_profile <- get_batch_profile_lik(corhmm_obj = corhmm_fit,
range_factor = 10000,
n_points = 20,
ncores = 10,
dredge = FALSE)
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
corhmm_fit <- corHMM(phy = phy, data = data, rate.cat = 1)
corhmm_fit_dredge <- corHMM:::corHMMDredge(phy = phy, data = data, 1, pen_type = "l1")
corhmm_profile <- corHMM:::get_batch_profile_lik(corhmm_obj = corhmm_fit,
range_factor = 10000,
n_points = 20,
ncores = 10,
dredge = FALSE)
dredge_profile <- corHMM:::get_batch_profile_lik(corhmm_obj = corhmm_fit_dredge,
range_factor = 10000,
n_points = 20,
ncores = 10,
dredge = TRUE)
plot_batch_profile_lik(corhmm_profile)
corHMM:::plot_batch_profile_lik(corhmm_profile)
corHMM:::plot_batch_profile_lik(dredge_profile)
corHMM:::plot_batch_profile_lik(corhmm_profile)
corHMM:::plot_batch_profile_lik(dredge_profile)
# simple two character simulation
setwd("~/corhmm-dredge/")
library(corHMM)
library(parallel)
library(MASS)
library(MCMCpack)
source("code/utils.R")
nSim <- 100
if (detectCores()>100){
mccores <- 100
}else{
mccores <- 4
}
trees <- lapply(dir("trees/", full.names = TRUE), read.tree)
phy <- trees[[1]]
phy
phy
phy <- trees[[1]]
phy
# which simulation number
simulation <- "02"
overwrite <- FALSE
# the various file names
par_table_name <- paste0("par_table-", simulation, ".csv")
full_dat_name <- paste0("full_data-", simulation, ".RDS")
cor_dat_name <- paste0("cor_data-", simulation, ".RDS")
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=2, nStates=2, nRateClass=1)
index_mat
get_index_mat
index_mat
get_index_mat
getStateMat4Dat
