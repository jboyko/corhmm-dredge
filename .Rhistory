restart.set<-lapply(1:nstarts, random.restart)
}
#Finds the best fit within the restart.set list
best.fit<-which.min(unlist(lapply(restart.set, function(x) x[1])))
#Generates an object to store results from restart algorithm:
out<-NULL
out$objective=unlist(restart.set[[best.fit]][,1])
out$solution=unlist(restart.set[[best.fit]][,2:(model.set.final$np+1)])
loglik <- -out$objective
est.pars <- exp(out$solution)
}else{
# the user has specified initial params
cat("Beginning subplex optimization routine -- Starting value(s):", ip, "\n")
ip=ip
out = nloptr(x0=rep(log(ip), length.out = model.set.final$np), eval_f=dev.corhmm, lb=lower, ub=upper, opts=opts, phy=phy,liks=model.set.final$liks,Q=model.set.final$Q,rate=model.set.final$rate,root.p=root.p, rate.cat = rate.cat, order.test = order.test, lewis.asc.bias = lewis.asc.bias)
loglik <- -out$objective
est.pars <- exp(out$solution)
}
}
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
MK_3state <- corHMM(phy = phy, data = data, rate.cat = 1)
MK_3state
dredge_test <- corHMM:::corHMMDredge(phy = phy, data = data, max.rate.cat = 1)
debug(corHMM:::corHMMDredge)
dredge_test <- corHMM:::corHMMDredge(phy = phy, data = data, max.rate.cat = 1)
library(corHMM)
data(primates)
phy <- multi2di(primates[[1]])
data <- primates[[2]]
MK_3state <- corHMM(phy = phy, data = data, rate.cat = 1)
MK_3state
dredge_test <- corHMM:::corHMMDredge(phy = phy, data = data, max.rate.cat = 1)
library(corHMM)
library(TreeSim)
n = 100
numbsim = 1
lambda = 1
mu = 0.5
Q <- matrix(c(-1,1,1,-1), 2, 2, byrow = TRUE)
root.p <- c(1,0)
phy <- sim.bd.taxa(n, numbsim, lambda, mu, frac = 1, complete = FALSE, stochsampling = FALSE)[[1]]
dat <- corHMM:::simMarkov(phy, Q, root.p)
cor_dat <- data.frame(sp = names(dat$TipStates), d = dat$TipStates)
plot(phy, show.tip.label = FALSE)
tiplabels(pch = 16, col = dat$TipStates, cex = 0.5)
res_unreg <- corHMM(phy, cor_dat, 1)
res_reg <- corHMM:::corHMMDredge(phy, cor_dat, 1, node.states = "none")
res_unreg
res_reg
res_unreg
res_reg
nsim = 100
n = 100
numbsim = 1
lambda = 1
mu = 0.5
Q <- matrix(c(-1,1,1,-1), 2, 2, byrow = TRUE)
root.p <- c(1,0)
phy <- sim.bd.taxa(n, numbsim, lambda, mu, frac = 1, complete = FALSE, stochsampling = FALSE)[[1]]
dat <- lapply(1:nsim, corHMM:::simMarkov(phy, Q, root.p))
phy <- sim.bd.taxa(n, numbsim, lambda, mu, frac = 1, complete = FALSE, stochsampling = FALSE)[[1]]
dat <- lapply(1:nsim, corHMM:::simMarkov(phy, Q, root.p))
dat <- lapply(1:nsim, function(x) corHMM:::simMarkov(phy, Q, root.p))
dat
cor_dat <- lapply(dat, function(x) data.frame(sp = names(x$TipStates), d = x$TipStates))
cor_dat
res_reg <- corHMM:::corHMMDredge(phy, cor_dat[[1]], 1)
res_reg
library(corHMM)
library(TreeSim)
nsim = 100
n = 100
numbsim = 1
lambda = 1
mu = 0.5
Q <- matrix(c(-1,1,1,-1), 2, 2, byrow = TRUE)
root.p <- c(1,0)
phy <- sim.bd.taxa(n, numbsim, lambda, mu, frac = 1, complete = FALSE, stochsampling = FALSE)[[1]]
dat <- lapply(1:nsim, function(x) corHMM:::simMarkov(phy, Q, root.p))
cor_dat <- lapply(dat, function(x) data.frame(sp = names(x$TipStates), d = x$TipStates))
res_reg <- corHMM:::corHMMDredge(phy, cor_dat[[1]], 1)
res_reg
res_unreg <- lapply(cor_dat, function(x) corHMM(phy, x, 1))
library(parallel)
res_unreg <- mclapply(cor_dat, function(x) corHMM(phy, x, 1), mc.cores = 10)
res_unreg <- mclapply(cor_dat, function(x) corHMM(phy, x, 1), mc.cores = 4)
res_unreg <- mclapply(cor_dat, function(x) corHMM(phy, x, 1), mc.cores = 10)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1), mc.cores = 10)
res_unreg
res_reg
res_unreg[[1]]$solution
unlist(res_unreg[[1]]$solution)
c(res_unreg[[1]]$solution)
c(res_unreg[[1]]$solution)[c(3,2)]
do.call(rbind, lapply(res_unreg, function(x) c(x[[1]]$solution)[c(3,2)]))
lapply(res_unreg, function(x) c(x[[1]]$solution)[c(3,2)])
do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_unreg <- do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_reg <- do.call(rbind, lapply(res_reg, function(x) c(x$solution)[c(3,2)]))
boxplot(rbind(df_unreg, df_reg)); abline(h = 1)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "waiting"), mc.cores = 10)
boxplot(cbind(df_unreg, df_reg)); abline(h = 1)
plot_data <- cbind(df_unreg, df_reg)
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
boxplot(plot_data); abline(h = 1)
res_reg
df_unreg <- do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_reg <- do.call(rbind, lapply(res_reg, function(x) c(x$solution)[c(3,2)]))
plot_data <- cbind(df_unreg, df_reg)
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
boxplot(plot_data); abline(h = 1)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "distance"), mc.cores = 10)
df_unreg <- do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_reg <- do.call(rbind, lapply(res_reg, function(x) c(x$solution)[c(3,2)]))
plot_data <- cbind(df_unreg, df_reg)
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
boxplot(plot_data); abline(h = 1)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "logl1"), mc.cores = 10)
df_unreg <- do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_reg <- do.call(rbind, lapply(res_reg, function(x) c(x$solution)[c(3,2)]))
plot_data <- cbind(df_unreg, df_reg)
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
boxplot(plot_data); abline(h = 1)
df_unreg - 1
bias_unreg = colMeans(df_unreg - 1)
bias = colMeans(plot_data - 1)
bias
bias = colMeans(plot_data) 1
bias = colMeans(plot_data) - 1
bias
colMeans(plot_data)
apply(plot_data, 2, var)
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 1)^2)
mse
rmse = sqrt(colMeans((plot_data - 1)^2))
rmse
data.frame(bias, varr, mse, rmse)
t(data.frame(bias, varr, mse, rmse))
log(1)
plot_data <- log(cbind(df_unreg, df_reg))
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
bias = colMeans(plot_data) - 0
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 0)^2)
rmse = sqrt(colMeans((plot_data - 1)^2))
t(data.frame(bias, varr, mse, rmse))
rmse = sqrt(colMeans((plot_data - 0)^2))
t(data.frame(bias, varr, mse, rmse))
var(1,1,1,10)
var(c(1,1,1,10))
var(c(1,1,1,1))
library(corHMM)
library(TreeSim)
library(parallel)
nsim = 100
n = 100
numbsim = 1
lambda = 1
mu = 0.5
Q <- matrix(c(-1,1,1,-1), 2, 2, byrow = TRUE)
root.p <- c(1,0)
phy <- sim.bd.taxa(n, numbsim, lambda, mu, frac = 1, complete = FALSE, stochsampling = FALSE)[[1]]
dat <- lapply(1:nsim, function(x) corHMM:::simMarkov(phy, Q, root.p))
cor_dat <- lapply(dat, function(x) data.frame(sp = names(x$TipStates), d = x$TipStates))
res_unreg <- mclapply(cor_dat, function(x) corHMM(phy, x, 1), mc.cores = 10)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "varr"), mc.cores = 10)
df_unreg <- do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_reg <- do.call(rbind, lapply(res_reg, function(x) c(x$solution)[c(3,2)]))
plot_data <- log(cbind(df_unreg, df_reg))
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
bias = colMeans(plot_data) - 0
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 0)^2)
rmse = sqrt(colMeans((plot_data - 0)^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(plot_data); abline(h = 1)
boxplot(plot_data); abline(h = 0)
bias = colMeans(plot_data) - 1
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 1)^2)
rmse = sqrt(colMeans((plot_data - 1)^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(plot_data); abline(h = 1)
plot_data <- (cbind(df_unreg, df_reg))
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
bias = colMeans(plot_data) - 1
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 1)^2)
rmse = sqrt(colMeans((plot_data - 1)^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(plot_data); abline(h = 1)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "logl1"), mc.cores = 10)
df_unreg <- do.call(rbind, lapply(res_unreg, function(x) c(x$solution)[c(3,2)]))
df_reg <- do.call(rbind, lapply(res_reg, function(x) c(x$solution)[c(3,2)]))
plot_data <- (cbind(df_unreg, df_reg))
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
bias = colMeans(plot_data) - 1
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 1)^2)
rmse = sqrt(colMeans((plot_data - 1)^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(plot_data); abline(h = 1)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "varrlog"), mc.cores = 10)
res_reg <- mclapply(cor_dat, function(x) corHMM:::corHMMDredge(phy, x, 1, pen_type = "varrlog"), mc.cores = 10)
# simple binary simulation
setwd("~/corhmm-dredge/")
library(corHMM)
library(parallel)
library(MASS)
source("code/utils.R")
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=1)
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
nSim = 100
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=1)
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
# creates a list of rate matrices for simulation
rate_mats <- get_rate_mats(index_mat, par_table)
rate_mat = rate_mats[[1]]
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
trees
trees <- lapply(dir("trees/", full.names = TRUE), read.tree)
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=1)
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
# creates a list of rate matrices for simulation
rate_mats <- get_rate_mats(index_mat, par_table)
rate_mat = rate_mats[[1]]
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
# format data
cor_dat <- lapply(full_dat, function(x) get_formatted_data(x, index_mat))
cor_dat
# fit model to data
res_unreg <- mclapply(cor_dat, function(x)
corHMM(phy, x, 1),
mc.cores = 10)
cor_dat
phy
phy <- trees[[1]]
# fit model to data
res_unreg <- mclapply(cor_dat, function(x)
corHMM(phy, x, 1),
mc.cores = 10)
res_reg <- mclapply(cor_dat, function(x)
corHMM:::corHMMDredge(phy, x, 1, pen_type = "logl1"),
mc.cores = 10)
df_unreg <- do.call(rbind, lapply(res_unreg, get_solution_from_res))
df_reg <- do.call(rbind, lapply(res_reg, get_solution_from_res))
plot_data <- (cbind(df_unreg, df_reg))
colnames(plot_data) <- c("01_unreg", "10_unreg", "01_reg", "10_reg")
bias = colMeans(plot_data) - 1
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - 1)^2)
rmse = sqrt(colMeans((plot_data - 1)^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(plot_data); abline(h = 1)
# simple two state simulation with hmms
setwd("~/corhmm-dredge/")
library(corHMM)
library(parallel)
library(MASS)
source("code/utils.R")
nSim = 100
trees <- lapply(dir("trees/", full.names = TRUE), read.tree)
phy <- trees[[1]]
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=2)
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
# modify for hidden states
par_table[,c(1,2)] <- par_table[,c(1,2)] * 5
par_table[,c(3,4)] <- par_table[,c(3,4)] / 5
par_table[,c(5,6)] <- par_table[,c(5,6)] * 2
# creates a list of rate matrices for simulation
rate_mats <- get_rate_mats(index_mat, par_table)
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
# format data
cor_dat <- lapply(full_dat, function(x) get_formatted_data(x, index_mat))
# fit model to data
res_unreg <- mclapply(cor_dat, function(x)
corHMM(phy, x, 2),
mc.cores = 10)
res_unreg_b <- mclapply(cor_dat, function(x)
corHMM(phy, x, 1),
mc.cores = 10)
supp_hmm <- which((unlist(lapply(res_unreg_b, function(x) x$AICc)) - unlist(lapply(res_unreg, function(x) x$AICc)))>-2)
supp_hmm
res_reg <- mclapply(cor_dat, function(x)
corHMM:::corHMMDredge(phy, x, 2, pen_type = "logl1", lambda = 1),
mc.cores = 10)
df_unreg <- do.call(rbind, lapply(res_unreg, get_solution_from_res))
df_reg <- do.call(rbind, lapply(res_reg, get_solution_from_res))
plot_data <- (cbind(df_unreg, df_reg))
bias = colMeans(plot_data - cbind(par_table, par_table))
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - cbind(par_table, par_table))^2)
rmse = sqrt(colMeans((plot_data - cbind(par_table, par_table))^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(plot_data); abline(h = colMeans(par_table))
bias = colMeans(log(plot_data) - log(cbind(par_table, par_table)))
varr = apply(log(plot_data), 2, var)
mse = colMeans((log(plot_data) - log(cbind(par_table, par_table)))^2)
rmse = sqrt(colMeans((log(plot_data) - log(cbind(par_table, par_table)))^2))
t(data.frame(bias, varr, mse, rmse))
boxplot(log(plot_data)); abline(h = colMeans(log(par_table)))
colMeans(par_table)
colMeans(plot_data)
df_reg[supp_hmm,]
supp_hmm
df_reg
df_reg[supp_hmm,]
supp_hmm <- which((unlist(lapply(res_unreg_b, function(x) x$AICc)) - unlist(lapply(res_unreg, function(x) x$AICc)))>0)
supp_hmm
supp_hmm <- which((unlist(lapply(res_unreg_b, function(x) x$AICc)) - unlist(lapply(res_unreg, function(x) x$AICc)))>2)
supp_hmm
supp_hmm <- which((unlist(lapply(res_unreg_b, function(x) x$AICc)) - unlist(lapply(res_unreg, function(x) x$AICc)))>0)
supp_hmm
df_reg[supp_hmm,]
par_table
t(data.frame(bias, varr, mse, rmse))
# simple two state simulation with hmms
setwd("~/corhmm-dredge/")
library(corHMM)
library(parallel)
library(MASS)
source("code/utils.R")
nSim = 100
trees <- lapply(dir("trees/", full.names = TRUE), read.tree)
phy <- trees[[1]]
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=2, nRateClass=1)
index_mat
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
par_table
index_mat
par_table[,c(3,4)] <- par_table[,c(3,4)] / 5
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
par_table
# creates a list of rate matrices for simulation
rate_mats <- get_rate_mats(index_mat, par_table)
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
full_dat
lapply(full_dat, function(x) table(x$TipStates))
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
lapply(full_dat, function(x) table(x$TipStates))
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
lapply(full_dat, function(x) table(x$TipStates))
# format data
cor_dat <- lapply(full_dat, function(x) get_formatted_data(x, index_mat))
# fit model to data
res_unreg <- mclapply(cor_dat, function(x)
corHMM(phy, x, 2),
mc.cores = 10)
# fit model to data
res_unreg <- mclapply(cor_dat, function(x)
corHMM(phy, x, 1),
mc.cores = 10)
res_reg <- mclapply(cor_dat, function(x)
corHMM:::corHMMDredge(phy, x, 1, pen_type = "logl1", lambda = 1),
mc.cores = 10)
unlist(lapply(full_dat, function(x) length(table(x$TipStates)) == 8))
res_unreg[unlist(lapply(full_dat, function(x) length(table(x$TipStates)) == 8))]
res_unreg <- res_unreg[unlist(lapply(full_dat, function(x) length(table(x$TipStates)) == 8))]
res_reg <- res_reg[unlist(lapply(full_dat, function(x) length(table(x$TipStates)) == 8))]
df_unreg <- do.call(rbind, lapply(res_unreg, get_solution_from_res))
df_reg <- do.call(rbind, lapply(res_reg, get_solution_from_res))
plot_data <- (cbind(df_unreg, df_reg))
bias = colMeans(plot_data - cbind(par_table, par_table))
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - cbind(par_table, par_table))^2)
par_table <- par_table[unlist(lapply(full_dat, function(x) length(table(x$TipStates)) == 8))]
df_unreg <- do.call(rbind, lapply(res_unreg, get_solution_from_res))
df_reg <- do.call(rbind, lapply(res_reg, get_solution_from_res))
plot_data <- (cbind(df_unreg, df_reg))
bias = colMeans(plot_data - cbind(par_table, par_table))
varr = apply(plot_data, 2, var)
plot_data
dim(plot_data)
dim(par_table)
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
par_table
par_table <- par_table[unlist(lapply(full_dat, function(x) length(table(x$TipStates)) == 8)), ]
df_unreg <- do.call(rbind, lapply(res_unreg, get_solution_from_res))
df_reg <- do.call(rbind, lapply(res_reg, get_solution_from_res))
plot_data <- (cbind(df_unreg, df_reg))
bias = colMeans(plot_data - cbind(par_table, par_table))
varr = apply(plot_data, 2, var)
mse = colMeans((plot_data - cbind(par_table, par_table))^2)
par_table
dim(par_table)
res_unreg
par_table
dim(par_table)
res_unreg
cor_dat
h
h
h
# simple two state simulation with hmms
setwd("~/corhmm-dredge/")
library(corHMM)
library(parallel)
library(MASS)
source("code/utils.R")
nSim = 100
trees <- lapply(dir("trees/", full.names = TRUE), read.tree)
phy <- trees[[1]]
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=3, nStates=2, nRateClass=1)
# samples the possible parameter values
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
# creates a list of rate matrices for simulation
rate_mats <- get_rate_mats(index_mat, par_table)
# simulate data
full_dat <- lapply(rate_mats, function(x) get_sim_data(trees[[1]], x, index_mat))
# format data
cor_dat <- lapply(full_dat, function(x) get_formatted_data(x, index_mat))
cor_dat
corHMM(phy, cor_dat[[1]], 1)
getStateMat4Dat(cor_dat[[1]])
tmp <- corHMM(phy, cor_dat[[1]], 1, p = 1:24)
tmp
tmp$solution
get_solution_from_res(tmp)
df_unreg
dim(df_unreg)
res_unreg
cor_dat
res_unreg <- NULL
# fit model to data
res_unreg <- mclapply(cor_dat, function(x)
corHMM(phy, x, 1),
mc.cores = 10)
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=4, nStates=2, nRateClass=1)
index_mat
2^4
par_table
par_table_name <- paste0("par_table_", simulation, ".csv")
simulation <- "01"
par_table_name <- paste0("par_table_", simulation, ".csv")
par_table_name
# the various file names
par_table_name <- paste0("par_table-", simulation, ".csv")
full_dat_name <- paste0("full_data-", simulation, ".RDS")
cor_dat_name <- paste0("cor_data-", simulation, ".RDS")
res_reg_name <- paste0("res_reg-", simulation, ".RDS")
res_unreg_name <- paste0("res_unreg-", simulation, ".RDS")
res_unreg_name
res_reg_name
cor_dat_name
full_dat_name
par_table_name
# simple binary simulation
setwd("~/corhmm-dredge/")
library(corHMM)
library(parallel)
library(MASS)
source("code/utils.R")
nSim <- 100
trees <- lapply(dir("trees/", full.names = TRUE), read.tree)
phy <- trees[[1]]
# which simulation number
simulation <- "01"
# the various file names
par_table_name <- paste0("par_table-", simulation, ".csv")
full_dat_name <- paste0("full_data-", simulation, ".RDS")
cor_dat_name <- paste0("cor_data-", simulation, ".RDS")
res_reg_name <- paste0("res_reg-", simulation, ".RDS")
res_unreg_name <- paste0("res_unreg-", simulation, ".RDS")
# creates an index mat appropriate for nchar, nstates, and nhidden
index_mat <- get_index_mat(nChar=1, nStates=2, nRateClass=1)
# parameter table generation
file_found <- par_table_name %in% dir("parameter_tables/")
file_found
# parameter table generation
file_found <- par_table_name %in% dir("parameter_tables/")
if(!data_file_found | overwrite){
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
write.csv(par_table, file = paste0("parameter_tables/", par_table_name))
}
# parameter table generation
file_found <- par_table_name %in% dir("parameter_tables/")
if(!file_found | overwrite){
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
write.csv(par_table, file = paste0("parameter_tables/", par_table_name))
}
overwrite <- TRUE
# parameter table generation
file_found <- par_table_name %in% dir("parameter_tables/")
if(!file_found | overwrite){
par_table <- get_par_table(index_mat, nSim, mean = 0, sd = 0.25)
write.csv(par_table, file = paste0("parameter_tables/", par_table_name))
}
par_table
